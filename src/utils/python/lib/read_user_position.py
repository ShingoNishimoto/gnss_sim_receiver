"""
 read_user_position.py
   read_user_position (filename)

 Open and read user position log file (.csv) generated by bladeGPS into Python, and
 return the contents.

 Shingo Nishimoto, 2024.

      Args:
        filename: path to file

      Return:
        true_positions: list of time series position data with gpstime.

 -----------------------------------------------------------------------------

 GNSS-SDR is a Global Navigation Satellite System software-defined receiver.
 This file is part of GNSS-SDR.

 Copyright (C) 2022  (see AUTHORS file for a list of contributors)
 SPDX-License-Identifier: GPL-3.0-or-later

 -----------------------------------------------------------------------------
"""

import numpy as np
import pandas as pd
import pyproj
import utm
from scipy.interpolate import CubicSpline


def get_interpolated_positions(filename: str, receiver_time: np.array) -> np.array:
    return interpolate_user_position(read_user_position(filename), receiver_time)

def read_user_position(filename: str) -> np.array:

    user_positions = np.loadtxt(filename, delimiter=',', skiprows=1)
    # print(user_positions)
    return user_positions

def interpolate_user_position(user_positions: np.array, receiver_time: np.array) -> np.array:
    # Scipy
    interpolated_position = np.empty((3, len(receiver_time)))
    for i in range(3):
        cubic_spline = CubicSpline(user_positions.T[0], user_positions.T[i + 1], bc_type='natural')
        interpolated_position[i] = cubic_spline(receiver_time)

    # # Pandas interpolation
    # df = pd.DataFrame({'t': user_positions.T[0], 'x': user_positions.T[1],
    #                    'y': user_positions.T[2], 'z': user_positions.T[3]})

    # original_size = len(user_positions)
    # for i in range(len(receiver_time)):
    #     df.loc[i + original_size] = [receiver_time[i], np.nan, np.nan, np.nan]

    # df = df.sort_values('t')
    # df.reset_index(inplace=True, drop=True)
    # # Cubic spline interpolation
    # # df['x_interpolated'] = df['x'].interpolate(method='spline', order=2)
    # # df['y_interpolated'] = df['y'].interpolate(method='spline', order=2)
    # # df['z_interpolated'] = df['z'].interpolate(method='spline', order=2)
    # # Pchip interpolation
    # # df['x_interpolated'] = df['x'].interpolate(method='pchip')
    # # df['y_interpolated'] = df['y'].interpolate(method='pchip')
    # # df['z_interpolated'] = df['z'].interpolate(method='pchip')
    # # polynomial interpolation
    # df['x_interpolated'] = df['x'].interpolate(method='polynomial', order=3)
    # df['y_interpolated'] = df['y'].interpolate(method='polynomial', order=3)
    # df['z_interpolated'] = df['z'].interpolate(method='polynomial', order=3)

    # df_interpolated = df.loc[df['x'].isna()]

    # interpolated_position = np.array([df_interpolated['x_interpolated'].values,
    #                                   df_interpolated['y_interpolated'].values,
    #                                   df_interpolated['z_interpolated'].values])
    # Compute UTM
    UTM_positions = []
    for pos_ecef in interpolated_position.T:
        UTM_positions.append(ecef_to_utm(pos_ecef))

    true_positions = np.append(interpolated_position, np.array(UTM_positions).T, axis=0)
    return true_positions
    # return interpolated_position

def ecef_to_utm(ecef_pos: np.array) -> np.array:
    x_ecef = ecef_pos[0]
    y_ecef = ecef_pos[1]
    z_ecef = ecef_pos[2]
    # Define the WGS84 ellipsoid
    wgs84 = pyproj.Proj(proj='geocent', ellps='WGS84', datum='WGS84')

    # Convert ECEF to lat/lon (geodetic coordinate)
    lat_lan_proj = pyproj.Proj(proj='longlat', datum='WGS84')
    transformer = pyproj.Transformer.from_crs(wgs84.crs, lat_lan_proj.crs)
    lon, lat, alt = transformer.transform(x_ecef, y_ecef, z_ecef)

    # Define the output UTM projection
    zone = utm.latlon_to_zone_number(lat, lon)
    utm_proj = pyproj.Proj(proj='utm', zone=zone, datum='WGS84')

    # Convert lat/lon to UTM
    transformer = pyproj.Transformer.from_crs(lat_lan_proj.crs, utm_proj.crs)
    easting, northing = transformer.transform(lon, lat)

    return np.array([easting, northing, alt])
